---
title: 使用csharp简单实现的bp神经网络
sidebar_position: 12
---

:::note
在此之前最好先安装 `Collapsenav.Net.Tool` nuget包
:::

BPNN是反向传播神经网络(Back Propagation Neural Network)算法, 是一种监督式学习的多层前馈神经网络, 可以说是现代神经网络的鼻祖和奠基者, 提出了反向传播算法用于更新连接权重

为了学习和熟悉bp神经网络, 我用 csharp 实现了一个简单的神经网络

![bpnetwork](/img/bpnn/bpnn.webp)

bp神经网络的结构如上图所示, 包括输入层, 隐藏层和输出层

每个圆形都是一个神经元(Neuron), 每层神经元之间通过突触(Synapse)连接

![neuron](/img/bpnn/neuron.webp)

一般来说一个神经元有以上组成部分

其结构类似下面这样

```csharp
public class Neuron
{
    /// <summary>
    /// 值
    /// </summary>
    public double Value { get; set; }
    /// <summary>
    /// 激活函数
    /// </summary>
    public ActivationFunction ActivationFunction { get; set; }
    /// <summary>
    /// 偏置
    /// </summary>
    public double Bias { get; set; }
    /// <summary>
    /// 输入连接
    /// </summary>
    public List<Synapse> Inputs { get; set; }
    /// <summary>
    /// 输出连接
    /// </summary>
    public List<Synapse> Outputs { get; set; }
}
```

`Inputs` 和 `Outputs` 分别对应输入输出的突触结构, 输入是与上一层所有神经元的连接, 输出是与下一层所有神经元的连接

然后来看一下突触的结构

![synapse](/img/bpnn/synapse.webp)

突触的结构相比神经元来说就非常简单了, 只有前后两个神经元和这条连接的对应权重

代码结构类似如下

```csharp
public class Synapse
{
    /// <summary>
    /// 输入端
    /// </summary>
    public Neuron Input { get; set; }
    /// <summary>
    /// 输出端
    /// </summary>
    public Neuron Output { get; set; }
    /// <summary>
    /// 权重
    /// </summary>
    public double Weight { get; set; }
}
```

神经元在计算的时候需要过一次激活函数, 虽然有 sigmoid 这样的经典, 但我觉得这边还是用简单的 Relu 比较好

![relu](/img/bpnn/relu.webp)

```csharp
/// <summary>
/// 激活函数
/// </summary>
public interface IActivationFunction
{
    /// <summary>
    /// 前向
    /// </summary>
    double Forward(double input);
}
public class ReLu : IActivationFunction
{
    public double Forward(double input) => input > 0 ? input : 0;
    public static ReLu Instance = new ReLu();
}
```

神经元接受上一层神经元的输出加权求和, 然后通过激活函数和偏置之后计算出自己的输出, 提供给下一层

因此在神经元中可以定义一个 `GetValue` 方法用于计算

```csharp
public class Neuron
{
    public double Value { get; set; }
    /// <summary>
    /// 激活函数(Relu)
    /// </summary>
    public ActivationFunction ActivationFunction { get; set; }
    public double Bias { get; set; }
    public List<Synapse> Inputs { get; set; }
    public List<Synapse> Outputs { get; set; }
    public double GetValue()
    {
        // 如果是输入层的神经元, 则直接返回输入值
        if (Inputs.NotEmpty())
            Value = ActivationFunction.Forward(Inputs.Sum(synapse => synapse.Weight * synapse.Input.GetValue()) + Bias);
        return Value;
    }
}
```

为了让更加符合神经网络的定义, 下面再加上 `Layer` 和 `Network` 结构的简单定义

```csharp
public class Layer : IEnumerable<Neuron>
{
    /// <summary>
    /// 上一层
    /// </summary>
    public Layer? Previous { get; set; }
    /// <summary>
    /// 下一层
    /// </summary>
    public Layer? Next { get; set; }
    /// <summary>
    /// 本层的神经元
    /// </summary>
    public Neuron[] Neurons { get; private set; }
    public IEnumerator<Neuron> GetEnumerator()
    {
        return ((IEnumerable<Neuron>)Neurons).GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return Neurons.GetEnumerator();
    }
}
public class NetWork
{
    public List<Layer> Layers { get; set; }
    /// <summary>
    /// 输入
    /// </summary>
    public Layer Input => Layers.First();
    /// <summary>
    /// 输出层
    /// </summary>
    public Layer Output => Layers.Last();
}
```

`Layer` 只有一个神经元集合, `Network` 只有一个 `层` 的集合

在设置好神经网络 `Input` 层神经元的 `Value` 后, 调用神经网络 `Output` 层每个神经元的 `GetValue` 即可获得整个网络的输出

这个过程被称为 `前向传播(Forward)`, 所以可以在 `Network` 中实现该方法

```csharp
public class NetWork
{
    public List<Layer> Layers { get; set; }
    /// <summary>
    /// 输入
    /// </summary>
    public Layer Input => Layers.First();
    /// <summary>
    /// 输出层
    /// </summary>
    public Layer Output => Layers.Last();
    public double[] Forward(double[] inputs)
    {
        // 为输入层的神经元复制
        Input.SelectWithIndex().ForEach(i => i.value.Value = inputs[i.index]);
        // 调用输出层的GetValue方法, 计算输出层的神经元的输出值
        return Output.Select(i => i.GetValue()).ToArray();
    }
}
```

`Forward` 接收一组输入值, 前向传播计算完成之后返回最后一层的输出

:::note
以上的内容是神经网络的前向传播, 接下来介绍下最重要的反向传播(Backward)
:::

反向传播(Backward)是神经网络中的一个非常重要的概念, 虽然网络可以通过前向传播用输出计算出输出, 但是其中的权重等参数都是随机的, 几乎不可能正好随机出一组可以拟合数据集的权重

因此我们需要在输出之后计算出输出值与正确值的误差, 然后将这个误差一层一层反向传播回去, 根据这个误差调整



