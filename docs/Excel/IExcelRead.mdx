# IExcelRead

:::info
由于使用了 `NPOI,EPPlus,MiniExcel` 三种实现, 所以简单封装了一个 `IExcelRead`, 试图简化使用

暂时来看是有效果的，对我来说效果非常好
:::

## 接口定义

:::info
`IExcelRead` 的定义类似下面这样
:::

```csharp
public interface IExcelRead<T> : IDisposable
{
    IEnumerable<T> this[string field] { get; }
    IEnumerable<T> this[long row] { get; }
    T this[long row, long col] { get; }
    T this[string field, long row] { get; }
    IEnumerable<string> Headers { get; }
    IDictionary<string, int> HeadersWithIndex { get; }
    long RowCount { get; }
}
```

为了方便使用, 又有

```csharp
public interface IExcelRead : IExcelRead<string> { }
```

会将 excel 中的所有数据都 ToString

:::tip
最佳实践中的导入功能就是依据 IExcelRead 实现的
:::

## 获取实例

:::note
现阶段拥有 `NPOIExcelRead EPPlusExcelRead MiniExcelRead` 三种实现
:::

```csharp
using IExcelRead reader = new NPOIExcelRead(filePath);
using IExcelRead reader = new EPPlusExcelRead(filePath);
using IExcelRead reader = new MiniExcelRead(filePath);
```

:::tip
为了降低心智负担, `IExcelRead` 有静态方法 `GetExcelRead`, 用以自动生成 `IExcelRead` 的实例

5M 以上的自动使用 `MiniExcel` 作为实现, 其他时候随机使用 EPPlus 或 NPOI
:::

```csharp
using IExcelRead reader = IExcelRead.GetExcelRead(filePath);
```

## 使用

### 获取单元格的值

```csharp
// 第 1 行 第 6 列
string value = reader[0, 5];
```

### 获取行

```csharp
var row = read[0];
```

### 获取列

:::info
我认为"列"与"行"不同, 是不适合直接用下标去获取的, 所以设计成传有"含义"的列名称
:::

```csharp
IEnumerable<string> col = read["Column"];
```

:::caution
尝试使用`yield return` 降低性能损耗, 但是有没有效果, 有多大效果, 这我就不知道了, 暂时也没有能力去验证
:::
:::danger
MiniExcelRead 由于 MiniExcel 的实现问题，在获取超出原表格范围的单元格数据时，可能会出现异常
:::
